package serialPort

import java.awt.Color;
 import java.awt.FlowLayout;
 import java.awt.Font;
 import java.awt.Frame;
 import java.awt.Graphics;
 import java.awt.GridLayout;
 import java.awt.Image;
 import java.awt.Label;
 import java.awt.Panel;
 import java.awt.Toolkit;
 import java.awt.event.KeyAdapter;
 import java.awt.event.KeyEvent;
 import java.awt.event.WindowAdapter;
 import java. awt.event.WindowEvent;

import javax.swing.JOptionPane;

import serialException.ExceptionWriter;

/ **
 * Main program
 * @author zhong
 *
 * / 
public  class Client extends Frame {
    
    / **
     * 
     * / 
    private  static  final  long serialVersionUID = 1L ;

    / **
     * Program interface width
     * / 
    public  static  final  int WIDTH = 800 ;
    
    / **
     * Program interface height
     * / 
    public  static  final  int HEIGHT = 620 ;
    
    / **
     * Program interface location (abscissa)
     * / 
    public  static  final  int LOC_X = 200 ;
    
    / **
     * Program interface location (ordinate)
     * / 
    public  static  final  int LOC_Y = 70 ;

    Color color = Color.WHITE;
    Image offScreen = null ;     // for double buffering
    
    // set the window of the icon (here I customize the Windows window icon icon, because it is really think that a small coffee icon does not look good =) 
    Toolkit toolKit = getToolkit ();
    Image icon = toolKit.getImage (Client. Class .getResource ("computer.png" ));
    
    // hold other class 
    DataView data new dataView ( this );     // main interface class (display monitoring data main panel)

    / **
     * Main method
     * @param args //
      * / 
    public  static  void main (String [] args) {
         new Client (). launchFrame ();    
    }
    
    / **
     * Display the main interface
     * / 
    Public  void launchFrame () {
         the this .setBounds (LOC_X, LOC_Y, WIDTH, HEIGHT);     // position setting procedures appear in the desktop 
        the this .setTitle ( "the CDIO Project");     // Setup heading 
        the this .setIconImage (icon);
         this .setBackground (Color.white);     // set the background color
        
        the this .addWindowListener ( new new WindowAdapter An () {
             // add the listener to the window state 
            public  void the windowClosing (WindowEvent the arg0) {
                 // when the window is closed 
                System.exit (0);     // Exit the program 
            }
            
        });

        the this .addKeyListener ( new new KeyMonitor ());     // add keyboard listeners 
        the this .setResizable ( false );     // window size can not change 
        the this .setVisible ( to true );     // display window
            
        new thread ( new RepaintThread ()). start ();     // open redraw thread 
    }
    
    / **
     * Draw the component elements of the program interface
     * / 
    public  void paint (Graphics g) {
        Color c = g.getColor ();
        
        g.setFont ( new Font ) , Font.BOLD, 40 ));
        g.setColor (Color.black);
        g.drawString ( "Welcome to the host computer real-time monitoring system", 45, 190 );
        
        g.setFont ( new Font ) , Font.ITALIC, 26 ));
        g.setColor (Color.BLACK);
        g.drawString ( "Version: 1.0 Powered By: ZhongLei", 280, 260 );
        
        g.setFont ( new Font ) , Font.BOLD, 30 ));
        g.setColor (color);
        g.drawString ( "---- click Enter to enter the main interface ----", 100, 480 );
         // make the text "---- click Enter key to enter the main interface ----" black and white flash 
        if ( color == Color.WHITE) color = Color.black;
         else  if (color == color.BLACK) color = Color.white;
        
        
    }
    
    / **
     * Double buffering mode to redraw the interface elements of the interface
     * / 
    public  void update (Graphics g) {
         if (offScreen == null ) offScreen = this .createImage (WIDTH, HEIGHT);
        Graphics gOffScreen = offScreen.getGraphics ();
        Color c = gOffScreen.getColor ();
        gOffScreen.setColor (Color.white);
        guseScreen.fillRect ( 0, 0, WIDTH, HEIGHT);     // redraw the background canvas 
        this .paint (gOffScreen);     // redraw the interface element 
        gOffScreen.setColor (c);
        g.drawImage (offScreen, 0, 0, null );     // Newly painted canvas "posted" on the original canvas 
    }
    
    / *
     * Internal class form to achieve the monitoring of keyboard events
     * / 
    private  class KeyMonitor extends KeyAdapter {

        public  void the keyReleased (KeyEvent E) {
             int the keyCode = e.getKeyCode ();
             IF (the keyCode == KeyEvent.VK_ENTER) {     // when listening to execute the following operations after each keystroke enter key 
                setVisible ( to false );     // 
                Faint welcome interface dataview.setVisible ( true );     / / display monitoring interface 
                dataview.dataFrame ();     / / initialization monitoring interface 
            }
        }
        
    }
    
    
    / *
     * Redraw the thread (redraw every 250 milliseconds)
     * / 
    private  class RepaintThread implements Runnable {
         public  void run () {
             while ( true ) {
                repaint ();
                try {
                    Thread.sleep ( 250 );
                } catch (InterruptedException e) {
                     // redraw a thread error throw an exception when creating a Dialog and display exception details 
                    String err = ExceptionWriter.getErrorInfoFromException (e);
                    JOptionPane.showMessageDialog ( null , err, "error" , JOptionPane.INFORMATION_MESSAGE);
                    System.exit ( 0 );
                }
            }
        }
        
    }
    
}
package serialException;

import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;

/ **
 * Is responsible for the incoming Exception in the error message extracted and converted into a string;
 * @author zhong
 *
 * / 
public  class ExceptionWriter {

    / **
     * Encapsulates the error message in the Exception into a string and returns the string
     * @param e contains the wrong Exception
     * @return error message string
      * / 
    public  static String getErrorInfoFromException (Exception e) {
            
            StringWriter sw = null ;
            PrintWriter pw = null ;
            
            try {  
                sw = new StringWriter ();  
                pw = new PrintWriter (sw);  
                e.printStackTrace (pw);  
                return "\ r \ n" + sw.toString () + "\ r \ n" ;  
                
            } catch (Exception e2) {  
                 return "error! Did not get the error message, please check and try again!" ;  
            } finally {
                 try {
                     if (pw! = null ) {
                        pw.close ();
                    }
                    if (sw! = null ) {
                        sw.close ();
                    }
                } catch (IOException e1) {
                    e1.printStackTrace ();
                }
            }
        }
}
package serialException;

public  class SerialPortParameterFailure extends Exception {
     / **
     * 
     * / 
    private  static  final  long serialVersionUID = 1L ;

    public SerialPortParameterFailure () {}

    @Override
    public String toString () {
         return "set the serial port parameters failed! open the serial port operation is not complete!" ;
    }
    
}package serialPort

import java.awt.Button;
 import java.awt.Choice;
 import java.awt.Color;
 import java.awt.Font;
 import java.awt.Frame;
 import java.awt.Graphics;
 import java.awt.Image;
 import java.awt.Label;
 import java.awt.Toolkit;
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
 import java.awt.event.WindowAdapter;
 import java.awt.event.WindowEvent;
 import java.util.List;
 import java.util.TooManyListenersException;

import javax.swing.JOptionPane;

import gnu.io.SerialPort;
 import gnu.io.SerialPortEvent;
 import gnu.io.SerialPortEventListener;
 import serialException. * ;

/ **
 * Monitoring data display class
 * @ author Zhong
 *
 * / 
public  class DataView extends Frame {
        
    / **
     * 
     * / 
    private  static  final  long serialVersionUID = 1L ;

    Client client = null ;

    private List <String> commList = null ;     // save the available port number 
    private SerialPort serialPort = null ;     // save the serial port object
    
    private Font font = new Font, "Font.BOLD, 25 );
    
    private label tem = new Label ("no data", Label.CENTER);     // temperature 
    private Label hum = new Label ("no data", label.CENTER);     // humidity 
    private Label pa = new Label (" no data ", Label.CENTER);     // pressure 
    Private the Label Rain = new new the Label (" no data ", Label.CENTER);     // rainfall 
    Private the Label win_sp = new new the Label (" no data ", Label.CENTER );     // wind speed 
    private Label win_dir = new Label ("no data", Label.CENTER);     // wind direction
    
    private choice betChart = new Choice ();     // serial port selection (drop-down box) 
    private Choice bpsChoice = new Choice ();     // baud rate selection
    
    private Button openSerialButton = new Button (open the serial port )
    
    Image offScreen = null ;     // re-painted canvas
    
    // set the window's icon 
    Toolkit toolKit = getToolkit ();
    Image icon = toolKit.getImage (DataView. Class .getResource ("computer.png" ));

    / **
     * Class constructor
     * @param client
      * / 
    public DataView (Client client) {
         this .client = client;
        commList = SerialTool.findPort ();     / / program initialization scan once a valid serial 
    }
    
    / **
     * Main menu window display;
     * Add Label, button, drop bar and related events to monitor;
     * / 
    Public  void DataFrame () {
         the this .setBounds (client.LOC_X, client.LOC_Y, client.WIDTH, client.HEIGHT);
         the this .setTitle ( "the CDIO Project" );
         the this .setIconImage (icon);
         the this .setBackground (Color.white);
         this .setLayout ( null );
        
        the this .addWindowListener ( new new WindowAdapter () {
             public  void the windowClosing (WindowEvent arg0) {
                 IF (serialPort =! null ) {
                     // close the serial port to release resources when the program exits 
                    SerialTool.closePort (serialPort);
                }
                System.exit ( 0 );
            }
            
        });
        
        tem.setBounds ( 140, 103, 225, 50 );
        tem.setBackground (Color.black);
        tem.setFont (font);
        tem.setForeground (Color.white);
        add (tem);
        
        hum.setBounds ( 520, 103, 225, 50 );
        hum.setBackground (Color.black);
        hum.setFont (font);
        hum.setForeground (Color.white);
        add (hum);
        
        pa.setBounds ( 140, 193, 225, 50 );
        pa.setBackground (Color.black);
        pa.setFont (font);
        pa.setForeground (Color.white);
        add (pa);

        rain.setBounds ( 520, 193, 225, 50 );
        rain.setBackground (Color.black);
        rain.setFont (font);
        rain.setForeground (Color.white);
        add (rain);
        
        win_sp.setBounds ( 140, 283, 225, 50 );
        win_sp.setBackground (Color.black);
        win_sp.setFont (font);
        win_sp.setForeground (Color.white);
        add (win_sp);
        
        win_dir.setBounds ( 520, 283, 225, 50 );
        win_dir.setBackground (Color.black);
        win_dir.setFont (font);
        win_dir.setForeground (Color.white);
        add (win_dir);
        
        // add the serial port select the option 
        commChoice.setBounds (160, 397, 200, 200 );
         // check if there is a available serial port, yes if the join option 
        if (commList == null || commList.size () <1 ) {
            JOptionPane.showMessageDialog ( null , "no search for valid serial port!", "Error" , JOptionPane.INFORMATION_MESSAGE);
        }
        else {
             for (String s: commList) {
                commChoice.add (s);
            }
        }
        add (commChoice);
        
        // add the baud rate option 
        bpsChoice.setBounds (526, 396, 200, 200 );
        bpsChoice.add ( "1200" );
        bpsChoice.add ( "2400" );
        bpsChoice.add ( "4800" );
        bpsChoice.add ( "9600" );
        bpsChoice.add ( "14400" );
        bpsChoice.add ( "19200" );
        bpsChoice.add ( "115200" );
        add (bpsChoice);
        
        // add the open serial port button 
        openSerialButton.setBounds (250, 490, 300, 50 );
        openSerialButton.setBackground (Color.lightGray);
        openSerialButton.setFont ( new Font ) , Font.BOLD, 20 ));
        openSerialButton.setForeground (Color.darkGray);
        add (openSerialButton);
        // add the event to open the serial port to listen to 
        openSerialButton.addActionListener ( new ActionListener () {

            public  void actionPerformed (ActionEvent e) {
                
                // Get the serial name 
                String commName = commChoice.getSelectedItem ();            
                 // Get the baud rate 
                String bpsStr = bpsChoice.getSelectedItem ();
                
                // check whether the serial name is correct 
                if (commName == null || commName.equals ("" )) {
                    JOptionPane.showMessageDialog ( null , "no search for valid serial port!", "Error" , JOptionPane.INFORMATION_MESSAGE);            
                }
                else (
                     // check whether the baud rate is correct 
                    if (bpsStr == null || bpsStr.equals ("" )) {
                        JOptionPane.showMessageDialog ( null , "baud rate fetch error!", "Error" , JOptionPane.INFORMATION_MESSAGE);
                    }
                    else {
                         // serial name, baud rate are correct when 
                        int bps = Integer.parseInt (bpsStr);
                         try {
                            
                            // Gets the port name and the serial port baud rate target 
                            serialPort = SerialTool.openPort (commName, bps);
                             // add a serial port on the target listener 
                            SerialTool.addListener (serialPort, new new SerialListener ());
                             // listen for success Prompt 
                            JOptionPane.showMessageDialog ( null , "Listen successfully, monitor data will be displayed later!", "Prompt" , JOptionPane.INFORMATION_MESSAGE);
                            
                        } The catch (SerialPortParameterFailure | NotASerialPort | NoSuchPort | PortInUse | TooManyListeners E1) {
                             // use when an error occurs in a specific Dialog prompt an error message 
                            JOptionPane.showMessageDialog ( null , E1, "error" , JOptionPane.INFORMATION_MESSAGE);
                        }
                    }
                }
                
            }
        });
        
        
        this .setResizable ( false );
        
        new thread ( new RepaintThread ()). start ();     // Start the redraw thread
        
    }
    
    / **
     * Draw the main interface component elements
     * / 
    public  void paint (Graphics g) {
        Color c = g.getColor ();
        
        g.setColor (Color.black);
        g.setFont ( new Font ) , Font.BOLD, 25 ));
        g.drawString ( "temperature:", 45, 130 );

        g.setColor (Color.black);
        g.setFont ( new Font ) , Font.BOLD, 25 ));
        g.drawString ( "humidity:", 425, 130 );
        
        g.setColor (Color.black);
        g.setFont ( new Font ) , Font.BOLD, 25 ));
        g.drawString ( "pressure:", 45, 220 );
        
        g.setColor (Color.black);
        g.setFont ( new Font ) , Font.BOLD, 25 ));
        g.drawString ( "Rain:", 425, 220 );
        
        g.setColor (Color.black);
        g.setFont ( new Font ) , Font.BOLD, 25 ));
        g.drawString ( "wind speed:", 45, 310 );
        
        g.setColor (Color.black);
        g.setFont ( new Font ) , Font.BOLD, 25 ));
        g.drawString ( "wind direction:", 425, 310 );
        
        g.setColor (Color.gray);
        g.setFont ( new Font ) , Font.BOLD, 20 ));
        g.drawString ( "serial selection:", 45, 410 );
        
        g.setColor (Color.gray);
        g.setFont ( new Font ) , Font.BOLD, 20 ));
        g.drawString ( "baud rate:", 425, 410 );
        
    }
    
    / **
     * Double buffering mode to redraw the interface elements of the interface
     * / 
    public  void update (Graphics g) {
         if (offScreen == null ) offScreen = this .createImage (Client.WIDTH, Client.HEIGHT);
        Graphics gOffScreen = offScreen.getGraphics ();
        Color c = gOffScreen.getColor ();
        gOffScreen.setColor (Color.white);
        guseScreen.fillRect ( 0, 0, Client.WIDTH, Client.HEIGHT);     // redraw the background canvas 
        this .paint (gOffScreen);     // redraw the interface element 
        gOffScreen.setColor (c);
        g.drawImage (offScreen, 0, 0, null );     // Newly painted canvas "posted" on the original canvas 
    }
    
    / *
     * Redraw the thread (repainting every 30 milliseconds)
     * / 
    private  class RepaintThread implements Runnable {
         public  void run () {
             while ( true ) {
                 // call redraw method 
                repaint ();
                
                
                
                // scan available serial port 
                commList = SerialTool.findPort ();
                 if (commList! = Null && commList.size ()> 0 ) {
                    
                    // add a new scan to the available serial port 
                    for (String s: commList) {
                        
                        / / Whether the string name already exists, the initial default does not exist (in the commList exists but not in the commChoice, the new addition) 
                        boolean commExist = false ;    
                        
                        for ( int I = 0; I <commChoice.getItemCount (); I ++ ) {
                             IF (s.equals (commChoice.getItem (I))) {
                                 // the current scan to the serial port name already exists at the time of initial scan 
                                commExist = to true ;
                                 BREAK ;
                            }                    
                        }
                        
                        if (commExist) {
                             // The current scan to the serial name has been in the initial scan exists, directly into the next cycle 
                            continue ;
                        }
                        else (
                             // if there is no new string name to the available serial port drop-down list 
                            commChoice.add (s);
                        }
                    }
                    
                    // remove the
                     unused serial port for ( int i = 0; i <commChoice.getItemCount (); i ++ ) {
                        
                        / / Whether the serial port has expired, the initial default has been invalid (in the commChoice does not exist in the commList, it has been invalid) 
                        boolean commNotExist = true ;    
                        
                        for (String s: commList) {
                             if (s.equals (commChoice.getItem (i))) {
                                commNotExist = false ;    
                                 break ;
                            }
                        }
                        
                        if (commNotExist) {
                             // System.out.println ("remove" + commChoice.getItem (i)); 
                            commChoice.remove (i);
                        }
                        else {
                             continue ;
                        }
                    }
                    
                }
                else (
                     // if the scan to the commList is empty, then remove all existing serial 
                    commChoice.removeAll ();
                }

                try {
                    Thread.sleep ( 30 );
                } catch (InterruptedException e) {
                    String err = ExceptionWriter.getErrorInfoFromException (e);
                    JOptionPane.showMessageDialog ( null , err, "error" , JOptionPane.INFORMATION_MESSAGE);
                    System.exit ( 0 );
                }
            }
        }
        
    }
    
    / **
     * Create a serial listening class as an inner class
     * @author zhong
     *
     * / 
    private  class SerialListener implements SerialPortEventListener {
        
        / **
         * Handles monitored serial events
         * / 
        public  void serialEvent (SerialPortEvent serialPortEvent) {
            
            switch (serialPortEvent.getEventType ()) {

                case SerialPortEvent.BI: // 10 communication interrupt 
                    JOptionPane.showMessageDialog ( null , "communication with serial device interrupt", "error" , JOptionPane.INFORMATION_MESSAGE);
                     break ;

                case SerialPortEvent.OE: // 7 overflow (overflow) error

                case SerialPortEvent.FE: // 9 frame error

                case SerialPortEvent.PE: // 8 Parity error

                case SerialPortEvent.CD: // 6 Carrier detection

                case SerialPortEvent.CTS: // 3 Clear the data to be sent

                case SerialPortEvent.DSR: // 4 The data to be sent is ready

                case SerialPortEvent.RI: // 5 Ringing indication

                case SerialPortEvent.OUTPUT_BUFFER_EMPTY: // 2 output buffer is empty 
                    break ;
                
                case SerialPortEvent.DATA_AVAILABLE: // 1 There is available data in the serial port
                    
                    // System.out.println ("found data"); 
                    byte [] data = null ;
                    
                    try {
                         if (serialPort == null ) {
                            JOptionPane.showMessageDialog ( null , "Serial object is empty! Monitor failed!", "Error" , JOptionPane.INFORMATION_MESSAGE);
                        }
                        else {
                            data = SerialTool.readFromPort (serialPort);     // read the data into the byte array
                             // System.out.println (new String (data));
                            
                       / / Custom parsing process, you can actually use the process in accordance with their own needs to receive data after the analysis of the data
                            IF (Data == null || data.length <. 1) {     // check whether the data is correctly read     
                                JOptionPane.showMessageDialog ( null , "valid data during the read data is not acquired! Check device or program!", " Error " , JOptionPane.INFORMATION_MESSAGE);
                                System.exit ( 0 );
                            }
                            else {
                                String dataOriginal = new String (data);     // byte array data conversion bit to save the original data string 
                                String dataValid = "";     / / valid data (used to save the original data string to remove the beginning of the * String) 
                                [] elements = null ;     // used to save the string after the original string to get the string array    
                                 / / analytical data 
                                if (dataOriginal.charAt (0) == '*') {     // When the first character of the data is *, the data reception is completed and the                             
                                    dataValid = dataOriginal.substring (1 )
                                    Elements = dataValid.split ( "" );
                                     IF (Elements == null || elements.length <. 1) {     // check whether the data is parsed correctly 
                                        JOptionPane.showMessageDialog ( null , "data error parsing process, device or program check! "," Error " , JOptionPane.INFORMATION_MESSAGE);
                                        System.exit ( 0 );
                                    }
                                    else {
                                         try {
                                             // update interface Label value 
                                            / * for (int i = 0; i <elements.length; i ++) {
                                                System.out.println (elements [i]);
                                            } * / 
                                            // System.out.println ("win_dir:" + elements [5]); 
                                            tem.setText (elements [0] + "℃" );
                                            hum.setText (elements [ 1] + "%" );
                                            pa.setText (elements [ 2] + "hPa" );
                                            rain.setText (elements [ 3] + "mm" );
                                            win_sp.setText (elements [ 4] + "m / s" );
                                            win_dir.setText (elements [ 5] + "°" );
                                        } catch (ArrayIndexOutOfBoundsException e) {
                                            JOptionPane.showMessageDialog ( null , "Data parsing process error, update interface data failed! Please check device or program!", "Error" , JOptionPane.INFORMATION_MESSAGE);
                                            System.exit ( 0 );
                                        }
                                    }    
                                }
                            }
                            
                        }                        
                        
                    } catch (ReadDataFromSerialPortFailure | SerialPortInputStreamCloseFailure e) {
                        JOptionPane.showMessageDialog ( null , e, "error" , JOptionPane.INFORMATION_MESSAGE);
                        System.exit ( 0);     / / get a read error occurs when the error message to exit the system 
                    }    
                    
                    BREAK ;
    
            }

        }

    }
    
    
}
